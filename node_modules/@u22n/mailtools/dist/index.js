import { Autolinker } from 'autolinker';
import { load } from 'cheerio';
import { decode } from 'html-entities';
import * as htmlparser2 from 'htmlparser2';
import { validate } from 'email-validator';
import isValidDomain from 'is-valid-domain';

// src/linkify.ts
var GH_EMOJI_URL = "github.githubassets.com/images/icons/emoji";
function linkify(inputHtml) {
  const headOffset = inputHtml.indexOf("</head>");
  return Autolinker.link(inputHtml, {
    urls: {
      schemeMatches: true,
      tldMatches: true
    },
    email: true,
    phone: true,
    mention: false,
    hashtag: false,
    stripPrefix: false,
    stripTrailingSlash: false,
    newWindow: true,
    className: "",
    replaceFn: function(match) {
      if (match.getType() === "url") {
        const previousChar = inputHtml.charAt(match.getOffset() - 1);
        if (previousChar === "/") {
          return false;
        }
        if (match.getAnchorHref().includes(GH_EMOJI_URL)) {
          return false;
        }
        if (match.getOffset() < headOffset) {
          return false;
        }
        const tag = match.buildTag();
        tag.setAttr("rel", "noopener noreferrer");
      }
    }
  });
}
var linkify_default = linkify;

// ../../node_modules/.pnpm/domelementtype@2.3.0/node_modules/domelementtype/lib/esm/index.js
var ElementType;
(function(ElementType2) {
  ElementType2["Root"] = "root";
  ElementType2["Text"] = "text";
  ElementType2["Directive"] = "directive";
  ElementType2["Comment"] = "comment";
  ElementType2["Script"] = "script";
  ElementType2["Style"] = "style";
  ElementType2["Tag"] = "tag";
  ElementType2["CDATA"] = "cdata";
  ElementType2["Doctype"] = "doctype";
})(ElementType || (ElementType = {}));
function isTag(elem) {
  return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
}
ElementType.Root;
ElementType.Text;
ElementType.Directive;
ElementType.Comment;
ElementType.Script;
ElementType.Style;
ElementType.Tag;
ElementType.CDATA;
ElementType.Doctype;

// ../../node_modules/.pnpm/domhandler@5.0.3/node_modules/domhandler/lib/esm/node.js
function isTag2(node) {
  return isTag(node);
}
function isText(node) {
  return node.type === ElementType.Text;
}
function isComment(node) {
  return node.type === ElementType.Comment;
}

// src/cheerio-utils.ts
var TEXTUAL = /* @__PURE__ */ new Set([
  "root",
  "body",
  // Text content
  "p",
  "div",
  // Separators
  "hr",
  "br",
  // Inline text
  "span",
  "b",
  "a",
  "em",
  "i",
  "s",
  "strong"
]);
function isTextualElement(el) {
  return TEXTUAL.has(el.tagName);
}
function isDocument(el) {
  return el.tagName === "html";
}
function isBody(el) {
  return el.tagName === "body";
}
function isImage(el) {
  return el.tagName === "img";
}
function isRootElement(el) {
  return isBody(el) || isDocument(el) || el.tagName === "root";
}
function hasChildren(el) {
  return el.children && el.children.length > 0;
}
var EMPTY_REGEX = /^\s*$/;
function isEmpty(text) {
  if (isText(text)) {
    return EMPTY_REGEX.test(text.data || "");
  } else {
    return false;
  }
}
var EMPTY_LIKE_REGEX = /^\s*-*\s*$/;
function isEmptyLike(text) {
  if (isText(text)) {
    return EMPTY_LIKE_REGEX.test(text.data || "");
  } else {
    return false;
  }
}
function containsEmptyText(el) {
  if (!el)
    return true;
  if (isText(el)) {
    return isEmpty(el);
  } else if (hasChildren(el)) {
    return el.children.every((el2) => containsEmptyText(el2));
  } else {
    return true;
  }
}
function getTopLevelElement($) {
  const body = $("body");
  return body.length > 0 ? body.get(0) : $.root().children().get(0);
}
function toArray(selection) {
  const res = [];
  selection.each((i, el) => void res.push(el));
  return res;
}

// src/walkBackwards.ts
function* walkBackwards(el) {
  if (!el) {
    return;
  }
  if (el.children && el.children.length > 0) {
    for (let i = el.children.length - 1; i >= 0; i--) {
      yield* walkBackwards(el.children[i]);
    }
  }
  yield el;
  return;
}
var walkBackwards_default = walkBackwards;
var ON_REGEXP = new RegExp(
  `^\\s*(${// Beginning of the line.
  [
    "On",
    // English,
    "Le",
    // French
    "W dniu",
    // Polish
    "Op",
    // Dutch
    "Am",
    // German
    "P\xE5",
    // Norwegian
    "Den",
    // Swedish, Danish,
    "Em",
    // Portuguese
    "El"
    // Spanish
  ].join("|")})\\s`,
  "i"
);
var WROTE_REGEXP = new RegExp(
  `\\s(${// Ending of the line.
  [
    "wrote",
    "sent",
    // English
    "a \xE9crit",
    // French
    "napisa\u0142",
    // Polish
    "schreef",
    "verzond",
    "geschreven",
    // Dutch
    "schrieb",
    // German
    "skrev",
    // Norwegian, Swedish
    "escreveu",
    // Portuguese
    "escribi\xF3"
    // Spanish
  ].join("|")})\\s?:?\\s*$`,
  "i"
);
function isQuoteHeaderStart(el) {
  return isText(el) && ON_REGEXP.test(decode(el.data));
}
function isQuoteHeaderEnd(el) {
  return isText(el) && WROTE_REGEXP.test(decode(el.data));
}
function findQuoteString($) {
  const nodesToRemove = [];
  let seenQuoteHeaderEnd = false;
  const top = getTopLevelElement($);
  for (const el of walkBackwards_default(top)) {
    if (isDocument(el)) {
      continue;
    }
    if (isText(el)) {
      if (isEmpty(el)) {
        continue;
      }
      if (!seenQuoteHeaderEnd) {
        if (isQuoteHeaderEnd(el)) {
          seenQuoteHeaderEnd = true;
          nodesToRemove.push(el);
          if (isQuoteHeaderStart(el)) {
            break;
          } else {
            continue;
          }
        } else {
          break;
        }
      } else {
        nodesToRemove.push(el);
        if (isQuoteHeaderStart(el)) {
          break;
        } else {
          continue;
        }
      }
    } else {
      if (seenQuoteHeaderEnd) {
        nodesToRemove.push(el);
      }
      continue;
    }
  }
  return nodesToRemove;
}
var findQuoteString_default = findQuoteString;

// src/removeQuotations.ts
function removeQuotations($) {
  let didFindQuotation = false;
  const quoteElements = findAllQuotes($);
  didFindQuotation = didFindQuotation || quoteElements.length > 0;
  quoteElements.each((_, el) => void $(el).remove());
  const remainingQuoteNodes = findQuoteString_default($);
  didFindQuotation = didFindQuotation || remainingQuoteNodes.length > 0;
  remainingQuoteNodes.forEach((el) => $(el).remove());
  return { didFindQuotation };
}
function findAllQuotes($) {
  let quoteElements = $(
    [
      ".gmail_quote",
      "blockquote",
      '[class*="quote"]',
      // quote partial match for class names
      '[id*="quote"]'
      // quote partial match for id names
      // ENHANCEMENT: Add findQuotesAfterMessageHeaderBlock
      // ENHANCEMENT: Add findQuotesAfter__OriginalMessage__
    ].join(", ")
  );
  if (quoteElements.length === 0) {
    quoteElements = findAllQuotesOutlook($);
  }
  const quoteElementsSet = new Set(toArray(quoteElements));
  const withoutInlineQuotes = quoteElements.filter(
    (i, el) => !isInlineQuote(el, quoteElementsSet)
  );
  return withoutInlineQuotes;
}
function findAllQuotesOutlook($) {
  const quoteStart = $("div[style*='border-top']").first();
  const quotation = quoteStart.add(quoteStart.nextAll());
  if (quotation.length === 0) {
    return $();
  }
  const newHolder = $("<div></div>");
  quotation.each((_, el) => void newHolder.append($(el)));
  return newHolder;
}
function isInlineQuote(el, quoteSet) {
  const seen = /* @__PURE__ */ new Set();
  let head = el;
  while (head) {
    while (head && !head.nextSibling) {
      head = head.parentNode;
    }
    if (!head) {
      break;
    }
    head = head.nextSibling;
    const pile = [head];
    let node = null;
    while (node = pile.pop()) {
      if (seen.has(node)) {
        continue;
      }
      if (quoteSet.has(node)) {
        continue;
      }
      if (node.childNodes) {
        pile.push(...node.childNodes);
      }
      if (isImage(node)) {
        return true;
      }
      if (isText(node) && !isEmptyLike(node)) {
        return true;
      }
    }
    seen.add(head);
  }
  return false;
}
var removeQuotations_default = removeQuotations;

// src/removeTrailingWhitespace.ts
function removeTrailingWhitespace($, el = getTopLevelElement($)) {
  const hasChildren2 = el.childNodes && el.childNodes.length > 0;
  const isTextual = isTextualElement(el);
  if (isComment(el)) {
    $(el).remove();
    return true;
  } else if (isText(el)) {
    if (isEmptyLike(el)) {
      $(el).remove();
      return true;
    } else {
      const trimmed = el.data.trimEnd();
      $(el).replaceWith(trimmed);
      return false;
    }
  } else if (!isTextual) {
    return false;
  } else if (hasChildren2) {
    const wasEmpty = removeTrailingWhitespace($, el.lastChild);
    if (wasEmpty) {
      return removeTrailingWhitespace($, el);
    } else {
      return false;
    }
  } else if (isRootElement(el)) {
    return false;
  } else {
    $(el).remove();
    return true;
  }
}
var removeTrailingWhitespace_default = removeTrailingWhitespace;

// src/enforceViewport.ts
function enforceViewport($, desiredViewport = '<meta name="viewport" content="width=device-width">') {
  const viewports = $('meta[name="viewport"]');
  const hasViewport = viewports.length > 0;
  const viewportElement = $(desiredViewport);
  if (hasViewport) {
    viewports.each((_, el) => {
      $(el).remove();
    });
  }
  const head = $("head");
  head.append(viewportElement);
}
var enforceViewport_default = enforceViewport;

// src/blockRemoteContent/blockRemoteContentInAttributes.ts
var TAGS_THAT_HAVE_URL_ATTRIBUTES = {
  // Keep this one, since it won't be fetched unless clicked.
  // a: ['href'],
  applet: ["codebase"],
  area: ["href"],
  audio: ["src"],
  base: ["href"],
  blockquote: ["cite"],
  body: ["background"],
  button: ["formaction"],
  command: ["icon"],
  del: ["cite"],
  embed: ["src"],
  form: ["action"],
  frame: ["longdesc", "src"],
  head: ["profile"],
  html: ["manifest"],
  iframe: ["longdesc", "src"],
  img: ["longdesc", "src", "usemap"],
  input: ["src", "usemap", "formaction"],
  ins: ["cite"],
  link: ["href"],
  meta: ["content"],
  object: ["classid", "codebase", "data", "usemap"],
  q: ["cite"],
  script: ["src"],
  source: ["src"],
  track: ["src"],
  video: ["poster", "src"]
};
function blockRemoteContentInAttributes($, replacements) {
  const query = Object.keys(TAGS_THAT_HAVE_URL_ATTRIBUTES).join(",");
  $(query).each((_, el) => {
    const $el = $(el);
    if (!isTag2(el))
      return;
    if (el.tagName === "meta") {
      if (isMetaRefresh($el)) {
        $el.remove();
      }
      return;
    }
    getUrlAttributes(el.tagName, $el).filter((attr) => {
      const value = $el.attr(attr);
      return !value || isRemoteUrl(value);
    }).forEach((attr) => {
      const replacement = isImageAttribute(attr) ? replacements.image : replacements.other;
      $el.attr(attr, replacement);
    });
  });
}
function isMetaRefresh(meta) {
  const httpEquiv = meta.attr("http-equiv") || "";
  const content = meta.attr("content") || "";
  return /^refresh$/i.test(httpEquiv) || /^\d*;\s*URL=/.test(content);
}
function getUrlAttributes(tagName, $el) {
  const attrs = $el.attr();
  const potentialAttributes = TAGS_THAT_HAVE_URL_ATTRIBUTES[tagName] || [];
  return potentialAttributes.filter(
    Object.prototype.hasOwnProperty.bind(attrs)
  );
}
var IMAGE_ATTRIBUTES = /* @__PURE__ */ new Set([
  "background",
  "icon",
  "placeholder",
  "poster",
  "src",
  "srcset"
]);
function isImageAttribute(attr) {
  return IMAGE_ATTRIBUTES.has(attr);
}
function isRemoteUrl(attributeValue) {
  const isLocal = /^(?:data:|cid:)\S*$/.test(attributeValue);
  return !isLocal;
}
var blockRemoteContentInAttributes_default = blockRemoteContentInAttributes;

// src/blockRemoteContent/blockRemoteContentInStyle.ts
function blockRemoteContentInStyle($, replacementImageUrl) {
  $("style").each((_, styleEl) => {
    const styleText = $(styleEl).html() || "";
    const hasRemoteUrls = REG_STYLE_REMOTE_URLS.test(styleText);
    if (hasRemoteUrls) {
      const replacedText = replaceUrlsInStyle(styleText, replacementImageUrl);
      $(styleEl).text(replacedText);
    }
  });
  $("[style]").each((_, styledEl) => {
    const styleText = $(styledEl).attr("style");
    if (!styleText) {
      return;
    }
    const hasRemoteUrls = REG_STYLE_REMOTE_URLS.test(styleText);
    if (hasRemoteUrls) {
      const replacedText = replaceUrlsInStyle(styleText, replacementImageUrl);
      $(styledEl).attr("style", replacedText);
    }
  });
}
var REG_STYLE_REMOTE_URLS = /((?:url\(|(?:@import\s*)(?:url\()?)["']?)(?!(data|cid):)((?:\w*:)[^'")]*)/gi;
function replaceUrlsInStyle(styleText, replacement) {
  return styleText.replace(
    REG_STYLE_REMOTE_URLS,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    (match, ...[prefix, capturedUrl]) => {
      return `${prefix}${replacement}`;
    }
  );
}
var blockRemoteContentInStyle_default = blockRemoteContentInStyle;

// src/blockRemoteContent/index.ts
var TRANSPARENT_1X100_URL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";
function blockRemoteContentCheerio($, replacements = {}) {
  const { image = TRANSPARENT_1X100_URL, other = "#" } = replacements;
  blockRemoteContentInStyle_default($, image);
  blockRemoteContentInAttributes_default($, { image, other });
}
function blockRemoteContent(html, replacements = {}) {
  const $ = load(html);
  blockRemoteContentCheerio($, replacements);
  return $.html();
}

// src/appendStyle.ts
function appendStyle($, css) {
  const styleElement = $(`<style>${css}</style>`);
  const head = $("head");
  head.append(styleElement);
}
var appendStyle_default = appendStyle;
function fixBrokenHtml(inputHtml) {
  const fixedHead = fixBrokenHead(inputHtml);
  return fixedHead;
}
function fixBrokenHead(inputHtml) {
  const encounteredTags = /* @__PURE__ */ new Set();
  let isBroken = false;
  let headStartIndex;
  const parserDetect = new htmlparser2.Parser({
    onopentag(name) {
      if (name === "head") {
        headStartIndex = parserDetect.startIndex;
      }
      encounteredTags.add(name);
      const htmlTag = encounteredTags.has("html");
      const headTag = encounteredTags.has("head");
      const blockquoteTag = encounteredTags.has("blockquote");
      if (!htmlTag && headTag && !blockquoteTag) {
        isBroken = true;
        parserDetect.reset();
      } else if (htmlTag) {
        isBroken = false;
        parserDetect.reset();
      }
    }
  });
  parserDetect.write(inputHtml);
  parserDetect.end();
  if (!isBroken) {
    return inputHtml;
  }
  let fixedHtml = inputHtml.slice(headStartIndex);
  fixedHtml = `<html>${fixedHtml}</html>`;
  return fixedHtml;
}
var fixBrokenHtml_default = fixBrokenHtml;
var hasProtocol = (link) => {
  const lowerCaseLink = link.toLowerCase();
  return Boolean(lowerCaseLink.match(/^[a-z][a-z0-9+-.]*:/i));
};
var addHttpsToRelativeLinks = ($) => {
  $("a").each((_, link) => {
    const href = link.attribs.href;
    if (href && !hasProtocol(href)) {
      if (isValidDomain(href.split("/")[0] || "")) {
        link.attribs.href = `https://${href}`;
      } else if (validate(href)) {
        link.attribs.href = `mailto:${href}`;
      }
    }
  });
};
var addTitlesToLinks = ($) => {
  $("a").each((_, link) => {
    if (link.attribs.title) {
      link.attribs.title += ` (${link.attribs.href})`;
    } else {
      link.attribs.title = link.attribs.href || "";
    }
  });
};
var enhanceLinks = ($) => {
  addHttpsToRelativeLinks($);
  addTitlesToLinks($);
};

// src/removeStyles.ts
function removeStyles($, styles) {
  const cssAttributesToRemove = styles || [
    "background-color",
    "font-family",
    "font-size"
  ];
  $("*").each((index, element) => {
    const style = $(element).attr("style");
    if (style !== void 0 && style.trim() === "") {
      $(element).removeAttr("style");
    } else if (style) {
      const styles2 = style.split(";");
      const filteredStyles = styles2.filter((style2) => {
        const splitStyles = style2.split(":");
        if (!splitStyles[0]) {
          return false;
        }
        const propertyName = splitStyles[0].trim() || "";
        return !cssAttributesToRemove.includes(propertyName);
      });
      if (filteredStyles.length === 0 || filteredStyles.length === 1 && filteredStyles[0] === "") {
        $(element).removeAttr("style");
      } else {
        $(element).attr("style", filteredStyles.join(";"));
      }
    }
  });
  return true;
}
var removeStyles_default = removeStyles;
function removeSignatures($, cleanedQuotations = false) {
  const returnData = {
    didFindSignature: false,
    foundSignaturePlainText: null,
    foundSignatureHtml: null
  };
  let cheerioToSearchForSignatures;
  let cheerioToSearchRemoveSignatures;
  if (cleanedQuotations) {
    cheerioToSearchForSignatures = $;
    cheerioToSearchRemoveSignatures = $;
  } else {
    const cloned$ = load($("*").html() || "");
    removeQuotations_default(cloned$);
    cheerioToSearchForSignatures = cloned$;
    cheerioToSearchRemoveSignatures = $;
  }
  const foundPrimarySignatureElements = findAllSignatures(
    cheerioToSearchForSignatures
  );
  const foundPrimarySignature = foundPrimarySignatureElements;
  foundPrimarySignature.find("div").each(function() {
    const div = $(this);
    if (div.children().length === 1 && div.children("div").length === 1) {
      const childDiv = div.children("div").first();
      div.replaceWith(childDiv);
    }
  });
  returnData.foundSignatureHtml = foundPrimarySignature.html();
  foundPrimarySignature.find("div,p").each(function(i, el) {
    if (i > 0) {
      $(el).before("\n");
    }
  });
  returnData.foundSignaturePlainText = foundPrimarySignature.text().trim().replace(/(\s?\n)+/g, "\n");
  const allSignatureElementsForRemoval = findAllSignatures(
    cheerioToSearchRemoveSignatures
  );
  allSignatureElementsForRemoval.each((_, el) => void $(el).remove());
  returnData.didFindSignature = foundPrimarySignatureElements.length > 0;
  return returnData;
}
function findAllSignatures($) {
  const signatureElements = $(
    [
      // Known Signature Matchers
      "signature",
      ".gmail_signature",
      ".protonmail_signature_block",
      "#ms-outlook-mobile-signature",
      "#Signature",
      // outlook web,
      // Generic Signature Matchers
      '[class*="signature"]',
      '[id*="signature"]'
    ].join(", ")
  );
  if (signatureElements.length === 0 && $("html").attr("xmlns:m")?.includes("microsoft")) {
    return findAllSignaturesOutlook($);
  }
  return signatureElements;
}
function findAllSignaturesOutlook($) {
  const start = $(
    ':has(>[style*="mso-ligatures"], >[style*="mso-fareast"])'
  ).first();
  const signatureTags = start.add(start.nextUntil("div[style*='border-top']"));
  const newHolder = $("<div></div>");
  signatureTags.each((_, el) => void newHolder.append($(el)));
  return newHolder;
}
var removeSignatures_default = removeSignatures;

// src/parseMessage.ts
async function parseMessage(emailHtml, options = {}) {
  const {
    cleanQuotations = false,
    cleanSignatures = false,
    autolink = false,
    enhanceLinks: enhanceLinks2 = false,
    forceViewport = false,
    noRemoteContent = false,
    includeStyle = false,
    cleanStyles = false,
    remoteContentReplacements = {}
  } = options;
  const result = {
    completeHtml: emailHtml,
    parsedMessageHtml: emailHtml,
    didFindQuotation: null,
    didFindSignature: null,
    foundSignaturePlainText: null,
    foundSignatureHtml: null
  };
  result.completeHtml = fixBrokenHtml_default(result.completeHtml);
  result.parsedMessageHtml = result.completeHtml;
  if (autolink) {
    result.completeHtml = linkify_default(result.completeHtml);
    result.parsedMessageHtml = result.completeHtml;
  }
  const $ = load(result.completeHtml);
  removeComments($);
  removeScripts($);
  removeStyleTags($);
  hoistSpecialTags($);
  removeTrackers($);
  if (enhanceLinks2) {
    enhanceLinks($);
  }
  if (noRemoteContent) {
    blockRemoteContentCheerio($, remoteContentReplacements);
  }
  if (forceViewport) {
    enforceViewport_default($, forceViewport);
  }
  if (includeStyle) {
    appendStyle_default($, includeStyle);
  }
  if (cleanStyles) {
    if (typeof cleanStyles !== "boolean") {
      removeStyles_default($, cleanStyles);
    }
    removeStyles_default($);
  }
  removeTrailingWhitespace_default($);
  result.completeHtml = $.html();
  result.parsedMessageHtml = result.completeHtml;
  if (cleanSignatures) {
    const { didFindSignature, foundSignatureHtml, foundSignaturePlainText } = removeSignatures_default($, cleanQuotations);
    result.didFindSignature = didFindSignature;
    result.foundSignatureHtml = foundSignatureHtml;
    result.foundSignaturePlainText = foundSignaturePlainText;
    if (containsEmptyText(getTopLevelElement($))) ; else {
      removeTrailingWhitespace_default($);
      result.parsedMessageHtml = $.html();
    }
  }
  if (cleanQuotations) {
    const { didFindQuotation } = removeQuotations_default($);
    if (containsEmptyText(getTopLevelElement($))) ; else {
      result.didFindQuotation = didFindQuotation;
      removeTrailingWhitespace_default($);
      result.parsedMessageHtml = $.html();
    }
  }
  return result;
}
function removeTrackers($) {
  const TRACKERS_SELECTORS = [
    // TODO: Improve by looking at inline styles as well
    'img[width="0"]',
    'img[width="1"]',
    'img[height="0"]',
    'img[height="1"]'
  ];
  const trackingUrls = [
    "click.ngpvan.com",
    "t.signaux",
    "t.senal",
    "t.sidekickopen",
    "t.sigopn",
    "bl-1.com",
    "mailstat.us/tr",
    "tracking.cirrusinsight.com",
    "app.yesware.com",
    "t.yesware.com",
    "mailfoogae.appspot.com",
    "launchbit.com/taz-pixel",
    "list-manage.com/track",
    "cmail1.com/t",
    "click.icptrack.com/icp/",
    "infusionsoft.com/app/emailOpened",
    "via.intercom.io/o",
    "mandrillapp.com/track",
    "t.hsms06.com",
    "app.relateiq.com/t.png",
    "go.rjmetrics.com",
    "api.mixpanel.com/track",
    "web.frontapp.com/api",
    "mailtrack.io/trace",
    "sdr.salesloft.com/email_trackers"
  ].map((url) => `img[src*="${url}"]`);
  TRACKERS_SELECTORS.push(...trackingUrls);
  const query = TRACKERS_SELECTORS.join(", ");
  $(query).each((_, el) => {
    $(el).remove();
  });
}
function removeScripts($) {
  $("script").each((_, el) => {
    $(el).remove();
  });
}
function removeStyleTags($) {
  $("style").each((_, el) => {
    $(el).remove();
  });
}
function removeComments($) {
  $("*").contents().each((_, el) => {
    if (el.type === "comment") {
      $(el).remove();
    }
  });
}
function hoistSpecialTags($) {
  $("*:not(body)").contents().each((_, el) => {
    if (el.type === "tag" && el.name.includes(":")) {
      const parent = $(el).parent();
      parent.append($(el).contents());
      $(el).remove();
    }
  });
}

export { blockRemoteContent, linkify_default as linkify, parseMessage };
